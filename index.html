<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>BUNTA</title>
    <style>
      html, body { margin: 0; padding: 0; overflow: hidden; width: 100%; height: 100%; background-color: black; }
      body { font-family: monospace; color: white; display: flex; align-items: center; justify-content: center; position: relative; }
      canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
      #text-container { padding: 20px 30px; text-align: left; z-index: 2; position: relative; }
      #text-container h1 { margin: 0 0 10px 0; font-weight: bold; }
      #text-container a { display: block; text-decoration: none; color: white; margin-bottom: 10px; transition: transform 0.2s ease; }
      #text-container a:hover { transform: translateX(5px); }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <div id="text-container">
      <h1>BUNTA</h1>
      <a href="portfolio.html">Portfolio</a>
      <a href="https://github.com/buntalogy" target="_blank">Github</a>
      <a href="https://x.com/buntalogy" target="_blank">X</a>
    </div>
    <script>
      const cellSize = 10, brushRadius = 2, simulationInterval = 100, fadeFactor = 0.95;
      const canvas = document.getElementById("canvas"), ctx = canvas.getContext("2d");
      let grid = [], gridCols = 0, gridRows = 0, lastSimTime = 0, isMouseDown = false;
      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gridCols = Math.floor(canvas.width / cellSize);
        gridRows = Math.floor(canvas.height / cellSize);
        initGrid();
      }
      window.addEventListener("resize", resize);
      resize();
      function initGrid() {
        grid = [];
        for (let y = 0; y < gridRows; y++) {
          let row = [];
          for (let x = 0; x < gridCols; x++) {
            row.push({ alive: false, hue: 0, decay: 0 });
          }
          grid.push(row);
        }
        const numPatches = Math.floor(Math.random() * 6) + 32;
        for (let p = 0; p < numPatches; p++) {
          const centerX = Math.floor(Math.random() * gridCols);
          const centerY = Math.floor(Math.random() * gridRows);
          const baseHue = Math.floor(Math.random() * 360);
          for (let i = 0; i < 12; i++) {
            const dx = Math.floor(Math.random() * 5) - 2;
            const dy = Math.floor(Math.random() * 5) - 2;
            const x = centerX + dx, y = centerY + dy;
            if (x >= 0 && x < gridCols && y >= 0 && y < gridRows) {
              const hueVariation = Math.floor(Math.random() * 21) - 10;
              grid[y][x] = { alive: true, hue: (baseHue + hueVariation + 360) % 360, decay: 1 };
            }
          }
        }
      }
      function updateGrid() {
        let newGrid = [];
        for (let y = 0; y < gridRows; y++) {
          newGrid[y] = [];
          for (let x = 0; x < gridCols; x++) {
            let aliveNeighbors = 0, hueSum = 0;
            for (let dy = -1; dy <= 1; dy++) {
              for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0) continue;
                const nx = (x + dx + gridCols) % gridCols;
                const ny = (y + dy + gridRows) % gridRows;
                if (grid[ny][nx].alive) {
                  aliveNeighbors++;
                  hueSum += grid[ny][nx].hue;
                }
              }
            }
            const cell = grid[y][x];
            let newCell = { alive: false, hue: cell.hue, decay: cell.decay };
            if (cell.alive) {
              if (aliveNeighbors === 2 || aliveNeighbors === 3) {
                newCell.alive = true;
                newCell.hue = aliveNeighbors > 0 ? (cell.hue + hueSum) / (aliveNeighbors + 1) : cell.hue;
                newCell.decay = 1;
              } else {
                newCell.alive = false;
                newCell.decay = cell.decay * fadeFactor;
              }
            } else {
              if (aliveNeighbors === 3) {
                newCell.alive = true;
                newCell.hue = hueSum / 3;
                newCell.decay = 1;
              } else {
                newCell.alive = false;
                newCell.decay = cell.decay * fadeFactor;
              }
            }
            if (newCell.decay < 0.05) newCell.decay = 0;
            newGrid[y][x] = newCell;
          }
        }
        grid = newGrid;
      }
      function drawGrid() {
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        for (let y = 0; y < gridRows; y++) {
          for (let x = 0; x < gridCols; x++) {
            const cell = grid[y][x];
            if (cell.decay > 0) {
              ctx.fillStyle = `hsla(${cell.hue}, 100%, 20%, ${cell.decay})`;
              ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
            }
          }
        }
      }
      function paintAt(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const mx = clientX - rect.left, my = clientY - rect.top;
        const col = Math.floor(mx / cellSize), row = Math.floor(my / cellSize);
        const hue = (mx / canvas.width) * 360;
        for (let j = -brushRadius; j <= brushRadius; j++) {
          for (let i = -brushRadius; i <= brushRadius; i++) {
            const r = row + j, c = col + i;
            if (r >= 0 && r < gridRows && c >= 0 && c < gridCols) {
              if (Math.sqrt(i * i + j * j) <= brushRadius) {
                grid[r][c] = { alive: true, hue: hue, decay: 1 };
              }
            }
          }
        }
      }
      canvas.addEventListener("mousedown", (e) => { isMouseDown = true; paintAt(e.clientX, e.clientY); });
      canvas.addEventListener("mousemove", (e) => { if (isMouseDown) paintAt(e.clientX, e.clientY); });
      canvas.addEventListener("mouseup", () => { isMouseDown = false; });
      canvas.addEventListener("mouseleave", () => { isMouseDown = false; });
      function simulateInitialEvolution() {
        const iterations = Math.floor(8000 / simulationInterval);
        for (let i = 0; i < iterations; i++) {
          updateGrid();
        }
      }
      function animate(timestamp) {
        if (!lastSimTime) lastSimTime = timestamp;
        if (timestamp - lastSimTime > simulationInterval) {
          updateGrid();
          lastSimTime = timestamp;
        }
        drawGrid();
        requestAnimationFrame(animate);
      }
      simulateInitialEvolution();
      requestAnimationFrame(animate);
    </script>
  </body>
</html>
